package main

import (
	"fmt"
	"math/bits"
)

func CalcLinearRec(N int, f, g []int) int {
	if N == 0 {
		return divMod(f[0], g[0])
	}
	for len(g) > 0 && g[len(g)-1] == 0 {
		g = g[:len(g)-1]
	}
	m := len(g)
	for N > 0 {
		for len(f) > 0 && f[len(f)-1] == 0 {
			f = f[:len(f)-1]
		}
		n := len(f)
		g_ := make([]int, len(g))
		copy(g_, g)
		for i := 0; i < m; i++ {
			if (i & 1) != 0 {
				g_[i] = (MOD - g_[i]) % MOD
			}
		}
		n += m - 1
		resize(&f, n)
		resize(&g, 2*m-1)
		f = con.Convolve(f, g_)
		g = con.Convolve(g, g_)
		for i := 0; i < n; i++ {
			if (i & 1) == (N & 1) {
				f[i>>1] = f[i]
			}
		}
		for i := 0; i < m; i++ {
			g[i] = g[i<<1]
		}
		resize(&f, (n+1-(N&1))>>1)
		resize(&g, m)
		N >>= 1
	}
	resize(&f, 1)
	return f[0]
}

var a [][]int = [][]int{
	{},
	{2},
	{6, 998244341},
	{18, 998243969, 1782, 998242409},
	{54, 998232485, 942336, 962172029, 735116148, 686205045, 919128525, 965563602, 690857919, 339400056},
	{162, 997955969, 215254272, 571978396, 815344320, 873213961, 801076986, 989754064, 532445263, 583240064, 366910267, 851660359, 972784237, 858393535, 552002507, 642255075, 623258511, 99682523, 36327220, 45799879, 47310057, 459902419, 51998005, 341669874, 240881533, 248657002},
	{486, 991164245, 165390125, 256786329, 85984338, 490499499, 748155772, 319306922, 802989661, 403264357, 243335441, 9674647, 133433634, 604226569, 633386003, 867063516, 682459889, 710187217, 725946725, 635389470, 950206956, 427059294, 887847009, 265039857, 894570957, 919035520, 204516933, 726425255, 334658090, 820494084, 308026872, 225897191, 55539530, 603455738, 11256457, 63608898, 483400220, 522457613, 335678028, 388544517, 615227826, 718043484, 472486256, 960147638, 779368927, 997731928, 950237755, 275403764, 616377013, 669365111, 348878867, 314690294, 214501189, 211396176, 549410598, 244367107, 747067668, 258339343, 43552296, 981753651, 583770457, 14640041, 970093844, 581367316, 538472671, 974067051, 268519581, 485479248, 917151558, 122563957, 590880575, 616426761, 410856389, 739949438, 368993064, 807781193},
	{1458, 835035521, 92887351, 186835929, 351999075, 221442226, 146449330, 917481481, 65612428, 534064176, 269739123, 649184201, 2281048, 420021030, 694720569, 331671670, 842786706, 590026276, 31607690, 203903431, 975543137, 239335112, 944697172, 151739188, 678690153, 918088494, 43360917, 899763832, 649249049, 283744044, 788183831, 897147005, 966956352, 953017667, 772424358, 777836651, 621160574, 950255293, 418569594, 228951771, 443558384, 260122573, 546615060, 154912099, 150859679, 320023028, 356381855, 328325808, 473750980, 222233346, 253030335, 191745763, 114300849, 471800197, 810328030, 66088214, 857912240, 104937506, 260298514, 960773982, 844878730, 879663148, 190528231, 134482293, 891077550, 443018335, 129536039, 423873296, 470582506, 973262861, 798330841, 318499682, 90815689, 612423469, 9110281, 440324532, 617039223, 778803171, 205402144, 296109363, 946929758, 260874884, 866483859, 979001012, 442297577, 183050456, 374598223, 413912687, 243029543, 474625555, 171763376, 411101564, 536674497, 738253211, 436835023, 785333144, 612352669, 554687117, 455688533, 905731894, 315598890, 979897736, 133396090, 87604764, 274605847, 545014513, 827989302, 889297498, 323580065, 176142518, 895811596, 771125573, 81762016, 571481163, 365210341, 41244001, 510595667, 690725074, 253809325, 306505498, 907933063, 755714788, 125777631, 367296451, 944337201, 967032206, 128267839, 302693148, 883376404, 986580988, 543037561, 121900822, 753317351, 906802422, 227535233, 652862428, 188218725, 978194267, 240086380, 1036245, 800450165, 838077837, 706458464, 853349746, 618734706, 772431261, 926525874, 163126783, 643732550, 463653891, 206630907, 258020115, 510920218, 917414987, 362147115, 457977905, 351659800, 977339772, 448766906, 113129451, 200008400, 211040134, 129490374, 319677508, 268829920, 699532020, 795796587, 189215012, 324380498, 318018725, 404330814, 304871492, 939668901, 815610721, 602723146, 775116618, 925931289, 263989370, 434556282, 346501072, 325510777, 682179178, 822804444, 217338918, 563983000, 729153186, 579440010, 770412051, 914728906, 635683619, 390344141, 223929754, 430815957, 684372940, 880964351, 414099386, 901973679, 471584067, 158671258, 993760999, 996482800, 635191148, 985664102, 343423618, 607912913, 207348281, 827851403, 942927978, 333127667, 686354402, 597190399, 746826454, 917178665, 701887874, 396414969, 428181039, 992210087, 120366065, 295592869, 277988198, 606395532, 250775123, 859407215, 252580097, 91143456, 203476799, 945414866, 435065360, 116929197, 945360188, 88494577, 767137944},
}
var b [][]int = [][]int{
	{},
	{3},
	{16, 998244326},
	{87, 998242913, 6183, 998237792},
	{528, 998161454, 5739200, 794169011, 985606941, 210679522, 777831988, 126141317, 5201730, 220846254},
	{3227, 994412993, 393855742, 566425941, 877370465, 425354021, 207853870, 660679731, 689997464, 215850254, 31658021, 37873191, 178397082, 307645285, 102470226, 259694005, 147391269, 47767918, 306983260, 78462983, 978390652, 549050844, 914438907, 635479916, 712290713, 952385028},
	{21360, 804534347, 386028155, 515552084, 697127522, 73733468, 435245632, 863841462, 157688469, 667321791, 314240094, 934815858, 146594939, 285766594, 406289707, 765516203, 483765132, 218071511, 346043608, 539153244, 233923984, 191633806, 131375376, 876725066, 773086150, 213567997, 364734448, 921114887, 670637654, 634665430, 833091569, 981923822, 359688050, 193892649, 806416525, 246198241, 979189505, 607798256, 952164402, 139779607, 870232400, 654623551, 636751288, 506149531, 64122644, 735224890, 367817821, 241154708, 265100495, 312124167, 306083386, 858777437, 605113400, 555386611, 871287933, 41137176, 162342283, 910739937, 753765664, 895761591, 874847636, 27003850, 490020327, 84675045, 573817087, 928346584, 350903861, 958838154, 322523075, 323364859, 7103340, 81997982, 749331039, 608649190, 9426478, 700458083},
	{143823, 505749098, 124202699, 492266340, 766677800, 309144593, 905446803, 395541231, 967267044, 38755912, 65406395, 518715150, 654569599, 194473513, 459776402, 241561051, 996970491, 664833617, 890455894, 922158237, 491854286, 151054005, 565386987, 448524377, 340288170, 498240289, 652482635, 988351732, 940296106, 455468386, 877073818, 279764967, 674962772, 277910861, 417771452, 341565194, 691789708, 667734783, 482849633, 354962253, 664754247, 968502382, 591477259, 696082324, 75280904, 291348901, 703392119, 261911179, 730400862, 150022620, 311629695, 262086209, 22395946, 473672193, 452908910, 694360139, 440358767, 293371314, 187921734, 436015421, 984937936, 486232241, 893664531, 147499472, 812574165, 576182094, 738914152, 416572086, 670863614, 816463320, 27574094, 143553123, 885514227, 540010780, 826433645, 480050762, 718131579, 435273467, 399985081, 281758448, 654868921, 850539343, 655640692, 174467126, 454096792, 843749613, 345709428, 209440170, 876115449, 743060842, 739697856, 777248659, 334106916, 636810438, 123159928, 292988359, 553532139, 862863418, 417383013, 381143031, 940830042, 485561715, 645424226, 807999035, 824938995, 551321699, 287653016, 503756210, 34359060, 917363080, 766138798, 476084266, 225993927, 282744380, 272914016, 97965348, 23020315, 722728443, 229011565, 536196433, 239123378, 190906345, 672155256, 957557133, 511220733, 628001747, 518050880, 50407707, 601785905, 448260559, 479412331, 592758343, 214512425, 118121270, 82436041, 460430831, 550495244, 314562884, 376519225, 643046463, 706987274, 839573632, 63240055, 795428495, 335871005, 430083014, 389224400, 740640542, 862126965, 792524752, 54983656, 293099838, 984700729, 186804782, 578565713, 131423695, 408281075, 973336966, 608806542, 771145326, 441223465, 988629217, 79335748, 228676060, 258602568, 131070747, 374586199, 449334780, 601719373, 388702971, 20959962, 155123336, 64327025, 707296372, 930417400, 375927370, 217131897, 139949949, 599629669, 611493656, 318322369, 661477615, 923306588, 401526653, 161512236, 523557466, 546858104, 2022859, 911166561, 350672074, 921703856, 23769823, 289242014, 477827214, 988998392, 368986551, 242136812, 409110009, 760351381, 972718413, 582164090, 64227882, 633605456, 9825629, 59672686, 523709095, 335530918, 967967291, 969087406, 355783457, 179778375, 98403838, 725924363, 655031426, 360971647, 271083834, 195080163, 296305509, 228639900, 632710681, 330555871, 310856381, 68946973, 317686152, 837881311, 860542363, 545711422, 955092624, 41022894, 738430980, 662926954, 67704104},
}

func main() {
	for x := range b {
		for i := range b[x] {
			b[x][i] = (MOD - b[x][i]) % MOD
		}
		b[x] = append([]int{1}, b[x]...)
	}
	var h, w int
	fmt.Scan(&h, &w)
	if h&3 != 0 || w&3 != 0 {
		fmt.Println(0)
		return
	}
	h >>= 2
	w >>= 2
	fmt.Println(CalcLinearRec(w-1, a[h], b[h]))
}

func resize(a *[]int, n int) {
	if len(*a) > n {
		*a = (*a)[:n]
	} else {
		n = n - len(*a)
		for i := 0; i < n; i++ {
			*a = append(*a, 0)
		}
	}
}

const MOD = 998244353
const MOD1 = 754974721
const MOD2 = 167772161
const MOD3 = 469762049

func powMod(a, e, mod int) int {
	res, m := 1, a
	for e > 0 {
		if e&1 != 0 {
			res = res * m % mod
		}
		m = m * m % mod
		e >>= 1
	}
	return res
}

const ROOT = 3
const ROOT1 = 11
const ROOT2 = 3
const ROOT3 = 3

var con = NewConvolution(MOD, ROOT)
var con1 = NewConvolution(MOD1, ROOT1)
var con2 = NewConvolution(MOD2, ROOT2)
var con3 = NewConvolution(MOD3, ROOT3)

// 特殊な剰余と原始根
// (2, 1)
// (167772161, 3)
// (469762049, 3)
// (754974721, 11)
// (924844033, 5)
// (998244353, 3)
// (1012924417, 5)
// (167772161, 3)
// (469762049, 3)
// (1224736769, 3)
// (1107296257, 10)

type Convolution struct {
	mod, primroot, rank2                      int
	root, iroot, rate2, irate2, rate3, irate3 []int
}

func NewConvolution(mod, primroot int) *Convolution {
	rank2 := bits.TrailingZeros(uint(mod - 1))
	if rank2 < 3 {
		panic("Panic!")
	}
	root := make([]int, rank2+1)
	iroot := make([]int, rank2+1)
	rate2 := make([]int, rank2-2+1)
	irate2 := make([]int, rank2-2+1)
	rate3 := make([]int, rank2-3+1)
	irate3 := make([]int, rank2-3+1)
	root[rank2] = powMod(primroot, (mod-1)>>rank2, mod)
	iroot[rank2] = powMod(root[rank2], mod-2, mod)
	for i := rank2 - 1; i >= 0; i-- {
		root[i] = root[i+1] * root[i+1] % mod
		iroot[i] = iroot[i+1] * iroot[i+1] % mod
	}
	prod, iprod := 1, 1
	for i := 0; i <= rank2-2; i++ {
		rate2[i] = root[i+2] * prod % mod
		irate2[i] = iroot[i+2] * iprod % mod
		prod = prod * iroot[i+2] % mod
		iprod = iprod * root[i+2] % mod
	}
	prod, iprod = 1, 1
	for i := 0; i <= rank2-3; i++ {
		rate3[i] = root[i+3] * prod % mod
		irate3[i] = iroot[i+3] * iprod % mod
		prod = prod * iroot[i+3] % mod
		iprod = iprod * root[i+3] % mod
	}
	return &Convolution{mod, primroot, rank2, root, iroot, rate2, irate2, rate3, irate3}
}

func ceilPow2(n int) int {
	x := 0
	for 1<<x < n {
		x++
	}
	return x
}

func (q *Convolution) butterfly(a []int) {
	mod := q.mod
	n := len(a)
	h := ceilPow2(n)
	len := 0
	for len < h {
		if h-len == 1 {
			p := 1 << (h - len - 1)
			rot := 1
			for s := 0; s < (1 << len); s++ {
				offset := s << (h - len)
				for i := 0; i < p; i++ {
					l := a[i+offset]
					r := a[i+offset+p] * rot % mod
					a[i+offset] = (l + r) % mod
					a[i+offset+p] = (l - r + mod) % mod
				}
				if s+1 != (1 << len) {
					rot = rot * q.rate2[bits.TrailingZeros(^uint(s))] % mod
				}
			}
			len++
		} else {
			p := 1 << (h - len - 2)
			rot := 1
			imag := q.root[2]
			for s := 0; s < (1 << len); s++ {
				rot2 := rot * rot % mod
				rot3 := rot2 * rot % mod
				offset := s << (h - len)
				for i := 0; i < p; i++ {
					mod2 := mod * mod
					a0 := a[i+offset]
					a1 := a[i+offset+p] * rot
					a2 := a[i+offset+2*p] * rot2
					a3 := a[i+offset+3*p] * rot3
					a1na3imag := (a1 + mod2 - a3) % mod * imag
					na2 := mod2 - a2
					a[i+offset] = (a0 + a2 + a1 + a3) % mod
					a[i+offset+p] = (a0 + a2 + (2*mod2 - a1 - a3)) % mod
					a[i+offset+2*p] = (a0 + na2 + a1na3imag) % mod
					a[i+offset+3*p] = (a0 + na2 + (mod2 - a1na3imag)) % mod
				}
				if s+1 != (1 << len) {
					rot = rot * q.rate3[bits.TrailingZeros(^uint(s))] % mod
				}
			}
			len += 2
		}
	}
}

func (q *Convolution) butterflyInv(a []int) {
	mod := q.mod
	n := len(a)
	h := ceilPow2(n)
	len := h
	for len > 0 {
		if len == 1 {
			p := 1 << (h - len)
			irot := 1
			for s := 0; s < (1 << (len - 1)); s++ {
				offset := s << (h - len + 1)
				for i := 0; i < p; i++ {
					l := a[i+offset]
					r := a[i+offset+p]
					a[i+offset] = (l + r) % mod
					a[i+offset+p] = (l - r + mod) % mod
				}
				if s+1 != (1 << (len - 1)) {
					irot = irot * q.irate2[bits.TrailingZeros(^uint(s))] % mod
				}
			}
			len--
		} else {
			p := 1 << (h - len)
			irot := 1
			iimag := q.iroot[2]
			for s := 0; s < (1 << (len - 2)); s++ {
				irot2 := irot * irot % mod
				irot3 := irot2 * irot % mod
				offset := s << (h - len + 2)
				for i := 0; i < p; i++ {
					a0 := a[i+offset]
					a1 := a[i+offset+p]
					a2 := a[i+offset+2*p]
					a3 := a[i+offset+3*p]
					a2na3iimag := (mod + a2 - a3) * iimag % mod
					a[i+offset] = (a0 + a1 + a2 + a3) % mod
					a[i+offset+p] = (a0 + (mod - a1) + a2na3iimag) * irot % mod
					a[i+offset+2*p] = (a0 + a1 + (mod - a2) + (mod - a3)) * irot2 % mod
					a[i+offset+3*p] = (a0 + (mod - a1) + (mod - a2na3iimag)) * irot3 % mod
				}
				if s+1 != (1 << (len - 2)) {
					irot = irot * q.irate3[bits.TrailingZeros(^uint(s))] % mod
				}
			}
			len -= 2
		}
	}
	iz := powMod(n, mod-2, mod)
	for i := 0; i < n; i++ {
		a[i] = a[i] * iz % mod
	}
}

func (q *Convolution) convolveFFT(a []int, b []int) []int {
	mod := q.mod
	finalsz := len(a) + len(b) - 1
	z := 1
	for z < finalsz {
		z *= 2
	}
	lena, lenb := len(a), len(b)
	la := make([]int, z)
	lb := make([]int, z)
	for i := 0; i < lena; i++ {
		la[i] = a[i]
	}
	for i := 0; i < lenb; i++ {
		lb[i] = b[i]
	}
	q.butterfly(la)
	q.butterfly(lb)
	for i := 0; i < z; i++ {
		la[i] *= lb[i]
		la[i] %= mod
	}
	q.butterflyInv(la)
	return la[:finalsz]
}

func (q *Convolution) ConvolutionNaive(a []int, b []int) []int {
	mod := q.mod
	n := len(a)
	m := len(b)
	ans := make([]int, n+m-1)
	if n < m {
		for j := 0; j < m; j++ {
			for i := 0; i < n; i++ {
				ans[i+j] += a[i] * b[j] % mod
				ans[i+j] %= mod
			}
		}
	} else {
		for i := 0; i < n; i++ {
			for j := 0; j < m; j++ {
				ans[i+j] += a[i] * b[j] % mod
				ans[i+j] %= mod
			}
		}
	}
	return ans
}

func (q *Convolution) Convolve(a []int, b []int) []int {
	n := len(a)
	m := len(b)
	if n == 0 || m == 0 {
		return []int{}
	}
	if m < n {
		n = m
	}
	if n <= 60 {
		return q.ConvolutionNaive(a, b)
	} else {
		return q.convolveFFT(a, b)
	}
}

func ConvolveLL(a, b []int) []int {
	n := len(a)
	m := len(b)
	if n == 0 || m == 0 {
		return []int{}
	}

	MOD1 := 754974721 // 2^24
	MOD2 := 167772161 // 2^25
	MOD3 := 469762049 // 2^26
	M2M3 := MOD2 * MOD3
	M1M3 := MOD1 * MOD3
	M1M2 := MOD1 * MOD2
	M1M2M3 := MOD1 * MOD2 * MOD3

	i1 := inv_gcd(MOD2*MOD3, MOD1).y
	i2 := inv_gcd(MOD1*MOD3, MOD2).y
	i3 := inv_gcd(MOD1*MOD2, MOD3).y

	c1 := con1.Convolve(a, b)
	c2 := con2.Convolve(a, b)
	c3 := con3.Convolve(a, b)

	c := make([]int, n+m-1)
	for i := 0; i < n+m-1; i++ {
		x := 0
		x += (c1[i] * i1) % MOD1 * M2M3
		x += (c2[i] * i2) % MOD2 * M1M3
		x += (c3[i] * i3) % MOD3 * M1M2
		diff := c1[i] - safe_mod((x), (MOD1))
		if diff < 0 {
			diff += MOD1
		}
		offset := [5]int{0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3}
		x -= offset[diff%5]
		c[i] = x
	}

	return c
}

type pair struct{ x, y int }

func inv_gcd(a, b int) pair {
	a = safe_mod(a, b)
	if a == 0 {
		return pair{b, 0}
	}
	s := b
	t := a
	m0 := 0
	m1 := 1
	for t > 0 {
		u := s / t
		s -= t * u
		m0 -= m1 * u
		tmp := s
		s = t
		t = tmp
		tmp = m0
		m0 = m1
		m1 = tmp
	}
	if m0 < 0 {
		m0 += b / s
	}
	return pair{s, m0}
}

func safe_mod(x, m int) int {
	x %= m
	if x < 0 {
		x += m
	}
	return x
}

func divMod(a, b int) int {
	ret := a * modInv(b)
	ret %= MOD
	return ret
}

func modInv(a int) int {
	b, u, v := MOD, 1, 0
	for b != 0 {
		t := a / b
		a -= t * b
		a, b = b, a
		u -= t * v
		u, v = v, u
	}
	u %= MOD
	if u < 0 {
		u += MOD
	}
	return u
}
